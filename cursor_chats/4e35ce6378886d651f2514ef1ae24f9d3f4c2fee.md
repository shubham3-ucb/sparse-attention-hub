# Add add_mask function to masker classes
_Exported on 7/3/2025 at 18:08:22 PDT from Cursor (1.2.1)_

---

**User**

Maskers: add a place holder add_mask function to Masker classes


<General Instructions>
1. If trying to delete some file, ensure that the contents of that file are refactored / moved somewhere else.
2. Before you start the task, first read and understand the sparse_attention_hub folder 
</General Instructions>


Add a function for the following classes as described.

Classes: ResearchMasker, FixedMasker, TopKMasker, TopPMasker:
add_mask:
	Parameters:
		keys
		queries
		values
		attention_mask
		sparse_meta_data
		previous_mask
		kwargs
	Implementation:
                This is a abstract function for these classes -- needs overriding. 

Classes: OracleTopK, LocalMasker, SinkMasker, CausalMasker, HashAttentionTopKMasker, DoubleSparsityTopKMasker, PQCache, MagicPig, RandomSamplingMasker:
add_mask:
	Parameters:
		keys
		queries
		values
		attention_mask
		sparse_meta_data
		previous_mask
		kwargs
	Implementation:
		just return the same mask for now.


---

**Cursor**

I'll help you add the `add_mask` function to the masker classes. First, let me explore the sparse_attention_hub folder structure to understand the codebase and locate all the relevant masker classes.


Now let me read the base classes to understand the current structure:


Now let me check the specific implementation files to understand the current structure and add the required `add_mask` functions. Let me start by reading a few implementation files to understand the pattern:


Now let me check the sampling implementations:


Let me check the other implementation files to see all the classes that need the new `add_mask` function:


Now I understand the structure. I can see that all the classes already have an `add_mask` method, but they need to be updated to match the new signature and implementation requirements. Based on the user's request, I need to:

1. Update the abstract base classes (`ResearchMasker`, `FixedMasker`, `TopKMasker`, `TopPMasker`) to have the new `add_mask` signature as an abstract method
2. Update the concrete implementation classes to have the new `add_mask` signature with the specified implementation

Let me start by updating the base classes:


```python
    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List["ResearchMasker"],
    ) -> None:
        """Add mask to attention computation."""
        pass

->

    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add mask to attention computation."""
        pass
```

```python
    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add fixed mask to attention computation."""
        pass

->

    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add fixed mask to attention computation."""
        pass
```

Now I need to update the sampling base class as well:


```python
class SamplingMasker(ResearchMasker):
    """Abstract base class for sampling-based maskers."""

    def __init__(self, config: SamplingMaskerConfig):
        """Initialize sampling masker with configuration."""
        super().__init__(config)

    @classmethod
    def create_from_config(cls, config: SamplingMaskerConfig) -> "SamplingMasker":
        """Create sampling masker instance from configuration."""
        return cls(config)

    pass

->

class SamplingMasker(ResearchMasker):
    """Abstract base class for sampling-based maskers."""

    def __init__(self, config: SamplingMaskerConfig):
        """Initialize sampling masker with configuration."""
        super().__init__(config)

    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add sampling mask to attention computation."""
        pass

    @classmethod
    def create_from_config(cls, config: SamplingMaskerConfig) -> "SamplingMasker":
        """Create sampling masker instance from configuration."""
        return cls(config)
```

I need to add the missing import for `Any` in the sampling base file:


```python
from dataclasses import dataclass
from typing import Union

from ..base import ResearchMasker, MaskerConfig

->

from dataclasses import dataclass
from typing import Union, Any

from ..base import ResearchMasker, MaskerConfig
```

Now I need to update all the concrete implementation classes. Let me start with the abstract classes that need the abstract method signature:


```python
class TopKMasker(FixedMasker):
    """Abstract base class for top-K maskers."""

    def __init__(self, config: TopKMaskerConfig):
        """Initialize top-K masker with configuration."""
        super().__init__(config)

    @classmethod
    def create_from_config(cls, config: TopKMaskerConfig) -> "TopKMasker":
        """Create top-K masker instance from configuration."""
        return cls(config)

->

class TopKMasker(FixedMasker):
    """Abstract base class for top-K maskers."""

    def __init__(self, config: TopKMaskerConfig):
        """Initialize top-K masker with configuration."""
        super().__init__(config)

    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add top-K mask to attention computation."""
        pass

    @classmethod
    def create_from_config(cls, config: TopKMaskerConfig) -> "TopKMasker":
        """Create top-K masker instance from configuration."""
        return cls(config)
```

```python
class TopPMasker(FixedMasker):
    """Abstract base class for top-P maskers."""

    def __init__(self, config: TopPMaskerConfig):
        """Initialize top-P masker with configuration."""
        super().__init__(config)

    @classmethod
    def create_from_config(cls, config: TopPMaskerConfig) -> "TopPMasker":
        """Create top-P masker instance from configuration."""
        return cls(config)

->

class TopPMasker(FixedMasker):
    """Abstract base class for top-P maskers."""

    def __init__(self, config: TopPMaskerConfig):
        """Initialize top-P masker with configuration."""
        super().__init__(config)

    @abstractmethod
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add top-P mask to attention computation."""
        pass

    @classmethod
    def create_from_config(cls, config: TopPMaskerConfig) -> "TopPMasker":
        """Create top-P masker instance from configuration."""
        return cls(config)
```

Now I need to update all the concrete implementation classes. Let me start with the ones that should return the same mask (as specified in the user's requirements):


```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add oracle top-K mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add oracle top-K mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add local mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add local mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add causal mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add causal mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add sink mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add sink mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add hash attention mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add hash attention mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add double sparsity mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add double sparsity mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add PQ cache mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add PQ cache mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add random sampling mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add random sampling mask."""
        # just return the same mask for now
        return previous_mask
```

```python
    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        previous_attention_mask: Any,
        prev_num: Any,
        prev_den: Any,
        maskers: List[ResearchMasker],
    ) -> None:
        """Add Magic Pig mask."""
        # Bare metal implementation - no functionality
        pass

->

    def add_mask(
        self,
        keys: Any,
        queries: Any,
        values: Any,
        attention_mask: Any,
        sparse_meta_data: Any,
        previous_mask: Any,
        **kwargs
    ) -> Any:
        """Add Magic Pig mask."""
        # just return the same mask for now
        return previous_mask
```

Now let me run the tests to make sure everything is working correctly:


The tests are failing because torch is not installed. Let me try to run a simpler test to check if the syntax is correct:


---

**User**

Fix the errors

---

**Cursor**

I can see the issue! The error is that `abstractmethod` is not imported in the sampling base file. I need to add the missing import.


```python
from dataclasses import dataclass
from typing import Union, Any

from ..base import ResearchMasker, MaskerConfig

->

from abc import abstractmethod
from dataclasses import dataclass
from typing import Union, Any

from ..base import ResearchMasker, MaskerConfig
```

Now let me run the tests again to see if this fixes the import error:


