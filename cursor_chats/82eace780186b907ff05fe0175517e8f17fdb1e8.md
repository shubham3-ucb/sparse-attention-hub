# Add functionality to Mask class
_Exported on 7/3/2025 at 17:50:31 PDT from Cursor (1.1.6)_

---

**User**

Mask: Add functionality

<General Instructions>
1. If trying to delete some file, ensure that the contents of that file are refactored / moved somewhere else.
2. Before you start the task, first read and understand the sparse_attention_hub folder 
</General Instructions>


In the Mask class:
1. Implement apply_mask:
	Parameters:
		Input : Tensor with shape same as the mask.
		if from_dense_mask:
			Output = input * self.mask
		If from_index:
			Dense_mask = get_dense_mask()
			Output = input * dense_mask

		return output
2. Implement class method create_empty_mask:
	Parameters : shape
	Returns a mask object which in its dense representation has all values 0


---

**Cursor**

I'll help you add the requested functionality to the Mask class. First, let me understand the structure of the sparse_attention_hub folder to get better context.


Now I understand the structure. Let me examine the current Mask class implementation to understand its structure better, and then add the requested functionality.


Now I understand the Mask class structure. I need to add two methods:

1. `apply_mask` - applies the mask to an input tensor
2. `create_empty_mask` - class method to create a mask with all zeros

Let me implement these methods:


```python
    def get_dense_mask(self) -> torch.Tensor:
        """
        Get the dense mask representation.
        
        Returns:
            Dense mask tensor
        """
        if self.from_dense_mask:
            return self.mask
        elif self.from_index:
            # Convert sparse representation to dense mask
            dense_mask = torch.zeros(self.shape, dtype=self.dtype)
            if self.indices is not None and len(self.indices) > 0:
                if self.data is not None:
                    dense_mask.view(-1)[self.indices] = self.data
                else:
                    dense_mask.view(-1)[self.indices] = 1.0
            return dense_mask
        else:
            raise RuntimeError("Mask object is in an invalid state")
    
    def apply_mask(self, input_tensor: torch.Tensor) -> torch.Tensor:
        """
        Apply the mask to an input tensor.
        
        Args:
            input_tensor: Input tensor with shape same as the mask
            
        Returns:
            Output tensor after applying the mask
        """
        if input_tensor.shape != self.shape:
            raise ValueError(f"input_tensor.shape must be {self.shape}, got {input_tensor.shape}")
        
        if self.from_dense_mask:
            return input_tensor * self.mask
        elif self.from_index:
            dense_mask = self.get_dense_mask()
            return input_tensor * dense_mask
        else:
            raise RuntimeError("Mask object is in an invalid state")
    
    @classmethod
    def create_empty_mask(
        cls,
        shape: Tuple[int, ...],
        dtype: torch.dtype = torch.float32
    ) -> "Mask":
        """
        Create a mask object with all values set to zero.
        
        Args:
            shape: Shape of the mask (*, n)
            dtype: Data type for the mask values
            
        Returns:
            Mask object with from_dense_mask=True and all zeros
        """
        empty_mask = torch.zeros(shape, dtype=dtype)
        return cls.create_mask_from_dense_mask(shape, empty_mask, dtype)
    
    def __repr__(self) -> str:
```

Perfect! I have successfully added the two requested methods to the Mask class:

## Summary of Changes

I've added the following functionality to the `Mask` class in `sparse_attention_hub/sparse_attention/utils/mask.py`:

### 1. `apply_mask` method
- **Parameters**: `input_tensor` - Tensor with shape same as the mask
- **Functionality**: 
  - If `from_dense_mask=True`: Returns `input * self.mask`
  - If `from_index=True`: Gets the dense mask using `get_dense_mask()` and returns `input * dense_mask`
- **Returns**: Output tensor after applying the mask
- **Error handling**: Validates that input tensor shape matches mask shape

### 2. `create_empty_mask` class method
- **Parameters**: `shape` - Shape of the mask, `dtype` - Data type (defaults to `torch.float32`)
- **Functionality**: Creates a mask object with all values set to zero in its dense representation
- **Returns**: Mask object with `from_dense_mask=True` and all zeros

Both methods follow the existing code style and patterns in the class, including proper type hints, docstrings, and error handling. The `apply_mask` method leverages the existing `get_dense_mask()` method for the sparse case, ensuring consistency with the class's internal logic.

---

**User**

Can you create this direclty from sparse representation

---

**Cursor**

I understand you want to create the empty mask directly from sparse representation instead of going through the dense representation. Let me modify the `create_empty_mask` method to create it directly using sparse indices and pointer.


```python
    @classmethod
    def create_empty_mask(
        cls,
        shape: Tuple[int, ...],
        dtype: torch.dtype = torch.float32
    ) -> "Mask":
        """
        Create a mask object with all values set to zero.
        
        Args:
            shape: Shape of the mask (*, n)
            dtype: Data type for the mask values
            
        Returns:
            Mask object with from_dense_mask=True and all zeros
        """
        empty_mask = torch.zeros(shape, dtype=dtype)
        return cls.create_mask_from_dense_mask(shape, empty_mask, dtype)

->

    @classmethod
    def create_empty_mask(
        cls,
        shape: Tuple[int, ...],
        dtype: torch.dtype = torch.float32
    ) -> "Mask":
        """
        Create a mask object with all values set to zero.
        
        Args:
            shape: Shape of the mask (*, n)
            dtype: Data type for the mask values
            
        Returns:
            Mask object with from_index=True and all zeros (empty sparse representation)
        """
        # For an empty mask, we have no non-zero indices
        empty_indices = torch.empty(0, dtype=torch.long)
        
        # Create ptr array with size equal to product of all dimensions except the last one, plus 1
        # All rows have 0 non-zero elements, so ptr is just zeros
        ptr_size = np.prod(shape[:-1]) + 1
        ptr = torch.zeros(ptr_size, dtype=torch.long)
        
        # No data since all values are zero
        data = torch.empty(0, dtype=dtype)
        
        return cls.create_mask_from_indices(shape, empty_indices, ptr, data, dtype)
```

Perfect! I've modified the `create_empty_mask` method to create the empty mask directly from sparse representation instead of going through the dense representation. Here's what the updated method does:

## Updated `create_empty_mask` Method

The method now creates an empty mask directly using sparse representation:

1. **Empty indices**: Creates an empty tensor `torch.empty(0, dtype=torch.long)` since there are no non-zero elements
2. **Pointer array**: Creates a pointer array of zeros with size `np.prod(shape[:-1]) + 1`, indicating that each row has 0 non-zero elements
3. **Empty data**: Creates an empty data tensor since all values are zero
4. **Returns**: Uses `create_mask_from_indices` to create a mask with `from_index=True`

This approach is more efficient for empty masks since:
- It doesn't allocate a full dense tensor filled with zeros
- It directly represents the sparse structure (no non-zero elements)
- It's consistent with the sparse representation paradigm used throughout the class

The resulting mask will have `from_index=True` and when `get_dense_mask()` is called on it, it will correctly return a tensor of zeros with the specified shape.

---

**User**

In apply_mask, if self.from_index is true, can you implement without converting to dense

---

**Cursor**

I understand you want to implement `apply_mask` for the sparse case without converting to dense representation. Let me modify the method to work directly with the sparse indices and data.


```python
    def apply_mask(self, input_tensor: torch.Tensor) -> torch.Tensor:
        """
        Apply the mask to an input tensor.
        
        Args:
            input_tensor: Input tensor with shape same as the mask
            
        Returns:
            Output tensor after applying the mask
        """
        if input_tensor.shape != self.shape:
            raise ValueError(f"input_tensor.shape must be {self.shape}, got {input_tensor.shape}")
        
        if self.from_dense_mask:
            return input_tensor * self.mask
        elif self.from_index:
            dense_mask = self.get_dense_mask()
            return input_tensor * dense_mask
        else:
            raise RuntimeError("Mask object is in an invalid state")

->

    def apply_mask(self, input_tensor: torch.Tensor) -> torch.Tensor:
        """
        Apply the mask to an input tensor.
        
        Args:
            input_tensor: Input tensor with shape same as the mask
            
        Returns:
            Output tensor after applying the mask
        """
        if input_tensor.shape != self.shape:
            raise ValueError(f"input_tensor.shape must be {self.shape}, got {input_tensor.shape}")
        
        if self.from_dense_mask:
            return input_tensor * self.mask
        elif self.from_index:
            # Apply mask directly using sparse representation
            output = input_tensor.clone()
            
            if self.indices is not None and len(self.indices) > 0:
                # Get the values to apply at the sparse indices
                mask_values = self.data if self.data is not None else torch.ones(len(self.indices), dtype=self.dtype)
                
                # Apply the mask values at the sparse indices
                output.view(-1)[self.indices] *= mask_values
            
            return output
        else:
            raise RuntimeError("Mask object is in an invalid state")
```

Perfect! I've updated the `apply_mask` method to work directly with the sparse representation without converting to dense. Here's how the new implementation works:

## Updated `apply_mask` Method for Sparse Case

When `self.from_index` is True, the method now:

1. **Clones the input tensor** to avoid modifying the original
2. **Checks if there are sparse indices** to apply
3. **Gets mask values**: Uses `self.data` if available, otherwise creates ones tensor
4. **Applies mask directly**: Multiplies the values at sparse indices by the corresponding mask values
5. **Returns the result**

### Key Benefits:
- **Memory efficient**: No need to create a full dense mask tensor
- **Computationally efficient**: Only operates on the non-zero elements
- **Direct sparse operation**: Works directly with indices and data
- **Preserves sparsity**: The output maintains the same structure as the input

The method handles both cases:
- When `self.data` is provided: uses the actual mask values
- When `self.data` is None: assumes mask values of 1.0 (binary mask)

This approach is much more efficient for sparse masks, especially when the sparsity is high, as it avoids the overhead of converting to and from dense representation.

---

**User**

Okay i ll keep the previous one its is cleaner. Moving on

---

**Cursor**

Understood! You're keeping the previous implementation of `apply_mask` that converts to dense representation for the sparse case, as it's cleaner and more straightforward. 

The Mask class now has both requested functionalities:
1. ✅ `apply_mask` method - applies the mask to input tensors
2. ✅ `create_empty_mask` class method - creates empty masks with all zeros

Is there anything else you'd like me to help you with regarding the Mask class or any other part of the sparse attention hub?

---

**User**

In creaet_empty_mask take parameter mask_type = index / dense and use that to create the correct type of representation 

---

**Cursor**

I'll modify the `create_empty_mask` method to accept a `mask_type` parameter that allows creating either sparse (index) or dense representation.


```python
    @classmethod
    def create_empty_mask(
        cls,
        shape: Tuple[int, ...],
        dtype: torch.dtype = torch.float32
    ) -> "Mask":
        """
        Create a mask object with all values set to zero.
        
        Args:
            shape: Shape of the mask (*, n)
            dtype: Data type for the mask values
            
        Returns:
            Mask object with from_dense_mask=True and all zeros
        """
        empty_mask = torch.zeros(shape, dtype=dtype)
        return cls.create_mask_from_dense_mask(shape, empty_mask, dtype)

->

    @classmethod
    def create_empty_mask(
        cls,
        shape: Tuple[int, ...],
        dtype: torch.dtype = torch.float32,
        mask_type: str = "dense"
    ) -> "Mask":
        """
        Create a mask object with all values set to zero.
        
        Args:
            shape: Shape of the mask (*, n)
            dtype: Data type for the mask values
            mask_type: Type of representation ("dense" or "index")
            
        Returns:
            Mask object with all zeros in the specified representation
        """
        if mask_type == "dense":
            empty_mask = torch.zeros(shape, dtype=dtype)
            return cls.create_mask_from_dense_mask(shape, empty_mask, dtype)
        elif mask_type == "index":
            # For an empty mask, we have no non-zero indices
            empty_indices = torch.empty(0, dtype=torch.long)
            
            # Create ptr array with size equal to product of all dimensions except the last one, plus 1
            # All rows have 0 non-zero elements, so ptr is just zeros
            ptr_size = np.prod(shape[:-1]) + 1
            ptr = torch.zeros(ptr_size, dtype=torch.long)
            
            # No data since all values are zero
            data = torch.empty(0, dtype=dtype)
            
            return cls.create_mask_from_indices(shape, empty_indices, ptr, data, dtype)
        else:
            raise ValueError(f"mask_type must be 'dense' or 'index', got {mask_type}")
```

Perfect! I've updated the `create_empty_mask` method to accept a `mask_type` parameter. Here's what the updated method does:

## Updated `create_empty_mask` Method

The method now accepts a `mask_type` parameter with two options:

### Parameters:
- `shape`: Shape of the mask (*, n)
- `dtype`: Data type for the mask values (defaults to `torch.float32`)
- `mask_type`: Type of representation - either "dense" or "index" (defaults to "dense")

### Functionality:

1. **`mask_type="dense"`** (default):
   - Creates a dense tensor of zeros
   - Returns a mask with `from_dense_mask=True`

2. **`mask_type="index"`**:
   - Creates an empty sparse representation
   - Empty indices tensor (no non-zero elements)
   - Pointer array of zeros (indicating no non-zero elements per row)
   - Empty data tensor
   - Returns a mask with `from_index=True`

3. **Error handling**:
   - Raises `ValueError` for invalid `mask_type` values

### Usage Examples:
```python
# Create empty dense mask (default)
empty_dense = Mask.create_empty_mask((10, 20))

# Create empty sparse mask
empty_sparse = Mask.create_empty_mask((10, 20), mask_type="index")
```

This gives users the flexibility to choose the representation type that best fits their use case, whether they prefer dense or sparse representation for empty masks.

```python
# Create empty dense mask (default)
empty_dense = Mask.create_empty_mask((10, 20))

# Create empty sparse mask
empty_sparse = Mask.create_empty_mask((10, 20), mask_type="index")
```

